// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module intelligence.suggestion_engine;

// Allows clients to subscribe to different Suggestion "channels" and iterate
// through the results. Supports both passive consumption of Suggestions based
// on contextual changes, as well as Suggestions derived from
// user-driven "Asks".
interface SuggestionManager {
  // Creates a subscription to the "interruptions" category of Suggestions.
  // Interruptions are delivered immediately once they become available, and
  // are potentially unlimited in number.
  //
  // Closing the |listener| pipe terminates the subscription.
  //
  // Any user interactions received by the client should be forwarded to the
  // SuggestionService by calling NotifyInteraction().
  SubscribeToInterruptions(SuggestionListener listener);

  // Creates a subscription to "Next" Suggestions, with changes sent to
  // |listener|, and binds |controller| to a service that offers control over
  // result paging.
  //
  // Closing the |controller| pipe or the |listener| pipe terminates the
  // subscription.
  SubscribeToNext(SuggestionListener listener, NextController& controller);

  // Should be called when the user initiates an "Ask". Results are sent to
  // |listener|, and changes to user input as well as paging controls are
  // made available through |controller|.
  //
  // Closing the |listener| pipe or the |controller| pipe signals to the
  // SuggestionService that the "Ask" has been completed or canceled.
  InitiateAsk(SuggestionListener listener, AskController& controller);

  // Notifies the SuggestionService that the user has interacted with the
  // given Suggestion in the manner described in |interaction|.
  NotifyInteraction(string suggestion_uuid, SuggestionInteraction interaction);
};

// Exposed through |InitiateAsk()| on the SuggestionService. Gives clients the
// ability to update the SuggestionService on changes to user input once a user
// initiates an "Ask" interaction.
interface AskController {
  // Use this to signal to the service that the user input has changed, and
  // results should be updated to reflect it.
  SetUserInput(UserInput input);

  // Sets the number of desired results. If the new count is larger than the
  // previous value, the corresponding SuggestionListener will get one or more
  // |OnAdd()| calls. If the new value is smaller, the listener will get one
  // or more |OnRemove()| calls.
  SetResultCount(int32 count);
};

interface NextController {
  // Sets the number of desired results. If the new count is larger than the
  // previous value, the corresponding SuggestionListener will get one or more
  // |OnAdd()| calls. If the new value is smaller, the listener will get one
  // or more |OnRemove()| calls.
  SetResultCount(int32 count);
};

interface SuggestionListener {
  // TODO(thatguy): Figure out what's the best pattern to use here, to make
  // sure that UI updates are smooth.
  // TODO(anwilson): Sit down with thatguy@ and hash this out.
  OnAdd(array<Suggestion> suggestions);
  OnRemove(string uuid);
  OnRemoveAll();
};

enum SuggestionInteractionType {
  SELECTED,
  DISMISSED
  // SNOOZED
};

struct SuggestionInteraction {
  SuggestionInteractionType type;

  // TODO(thatguy): Include parameters for each type of interaction where
  // applicable. Consider making this a union in lieu of the struct/enum combo.
};

union UserInput {
  string text;
  // Picture
  // Doodle
  // Live camera stream
};

struct Suggestion {
  // Uniquely and globally identifies this Suggestion.
  string uuid;

  // Specifies the sort order for Suggestions within a single subscription.
  float rank;

  SuggestionDisplayProperties display_properties;
};

// TODO(thatguy): This will likely be a union eventually, with different
// display descriptions for different kinds of Suggestions.
struct SuggestionDisplayProperties {
  string icon;  // logo?
  string headline;
  string subtext;
  string details;
};
