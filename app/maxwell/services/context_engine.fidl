// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module maxwell.context_engine;

// Top-level client provider interface that produces clients that can be used by
// various types of publishers or subscribers of context.
[ServiceName="maxwell.context_engine.ContextEngine"]
interface ContextEngine {
  // Registers a component that publishes context based on sensors and/or
  // network access. Such apps have publish-only access to Context Service.
  RegisterContextAcquirer(string url, ContextAcquirerClient& client);

  // Registers a component that infers higher level context from other available
  // context. Such apps have pub-sub access to Context Service.
  RegisterContextAgent(string url, ContextAgentClient& client);

  // Registers a component that produces suggestions based on available context.
  // Such apps have subscribe-only access to Context Service.
  RegisterSuggestionAgent(string url, SuggestionAgentClient& client);
};

// Client that should be requested by context acquirers. All context written by
// this client is attributed to the bound acquirer.
//
// Context may be pushed at any time, but Context Service will notify the
// publisher as to whether any subscribers exist. The publisher is free to not
// publish until subscribers exist, and to delete context once the last
// subscriber is removed.
[ServiceName="maxwell.context_engine.ContextAcquirerClient"]
interface ContextAcquirerClient {
  // Registers a potential context publisher and attains a publish link for it.
  // When the existence or nonexistence of subscribers changes, the publisher is
  // notified through the provided ContextPublisherController.
  Publish(string label, string schema, ContextPublisherController? controller,
          ContextPublisherLink& link);
};

// Client that should be requested by context agents. All context read or
// written by this client is attributed to the bound agent.
[ServiceName="maxwell.context_engine.ContextAgentClient"]
interface ContextAgentClient {
  // Registers a potential context publisher and attains a publish link for it.
  // When the existence or nonexistence of subscribers changes, the publisher is
  // notified through the provided ContextPublisherController.
  //
  // If the label/schema pair for this client has already been registered, the
  // new controller and link replace the old. The new controller is notified of
  // any existing subscribers, but no effort is made to notify the old
  // controller beyond closing the pipe.
  Publish(string label, string schema, ContextPublisherController? controller,
          ContextPublisherLink& link);

  // Registers a listener to a context label. Upon subscribing, the subscriber
  // is immediately updated with the last known value of the context unless the
  // publisher had invalidated it.
  Subscribe(string label, string schema, ContextSubscriberLink link);
  // TODO(thatguy) => (Subscription subscription);
};

// Client that should be requested by suggestion agents. All context read by
// this client is attributed to the bound agent.
[ServiceName="maxwell.context_engine.SuggestionAgentClient"]
interface SuggestionAgentClient {
  // Registers a listener to a context label.
  Subscribe(string label, string schema, ContextSubscriberLink link);
  // TODO(thatguy) => (Subscription subscription);
};

////////////////////////////////////////////////////////////////////////////////
// Publish
////////////////////////////////////////////////////////////////////////////////

// Optional listener interface that a context publisher can implement to be
// informed by Context Service that one or more subscribers has subscribed to
// the bound label and schema. This is recommended for acquirers and agents.
interface ContextPublisherController {
  // Indicates that one or more subscribers has subscribed to the context
  // published by this context publisher.
  OnHasSubscribers();
  // Indicates that all subscriber links to the context published by this
  // context publisher have closed. The publisher is free to stop publishing. If
  // the previously published context could become stale at the next
  // subscription prior to a new update from the publisher, the publisher should
  // invalidate the context by publishing null.
  OnNoSubscribers();
};

// An attributed link that allows a context publisher to write to a context
// label with a bound schema.
interface ContextPublisherLink {
  // Writes attributed context data to the bound label. To remove the context,
  // write null. Invalid JSON, including the empty string, should not be passed.
  // TODO(rosswang): Validate JSON or expand formats.
  Update(string? json_value);
};

////////////////////////////////////////////////////////////////////////////////
// Subscribe
////////////////////////////////////////////////////////////////////////////////

// An attributed link that listens to updates to a context label with a bound
// schema.
interface ContextSubscriberLink {
  // Receives an update for a context label.
  OnUpdate(ContextUpdate update);
};

struct ContextUpdate {
  string source;
  // TODO(thatguy): timestamp

  // This may be null, indicating that the value was deleted.
  string? json_value;
};

// Eventually, Subscribe() will return this, and give you further control over
// flow.
/*interface Subscription {
  // Pause()
  // Resume()
}*/

////////////////////////////////////////////////////////////////////////////////
// Query
////////////////////////////////////////////////////////////////////////////////

[ServiceName="maxwell.ContextQuery"]
interface ContextQuery {
  // Registers a query for a label and creates a listener to determine when the
  // query evaluates to true.
  RegisterQuery(string whoami, Query query);
  // TODO(afergan): Include this once thatguy submits
  // https://fuchsia-review.googlesource.com/c/11130/
  //              array<proposal_service.ExpiryCondition> expiry_conditions);
  // TODO(afergan): Add queryLinks interface.
  // queryLinks(Query query, ContextSubscriberLinkQueryWatcher watcher) =>
  //                (array<LinkService> initialMatches);
  // queryGraph(Query query) => (GraphSnapshot graph);
  // TODO(afergan) => (ContextSubscriberLinkQueryWatcher watcher);
};

union Query {
  ScopeModifier scopeModifier;
  Expression expression;
  StoryTerm storyTerm;
  DataPathTerm dataPathTerm;
  WildcardTerm wildcard;
};

// Scope modifiers descend the graph for matches. All query terms within a scope
// modifier until the next descent are tested per datum, i.e. label = “foo” And
// label = “bar” is a contradiction.
struct ScopeModifier {
  MatchScope scope;
  Query term;
};


struct Expression {
  Operator op;
  array<Query> terms;
};

enum Operator { Not, And, Or }; // Not = Nand

enum MatchScope {
  // Include self and all descendents.
  Recursive,
  // Exclude self; include only the first level of descendents.
  Children,
  // Stops descent on result depth, but continues descending the predicate test
  // used for matching. This is similar to a WHERE clause in SQL. Without
  // another scope modifier, this is simply equivalent to And.
  Where
};

union StoryTerm {
  string verb;
  string title;
  // TODO(afergan): Once Uris are supported in FIDL, change this type.
  string manifest;
  // CompositionType compositionType;
  bool isStoryActive;
  bool isModuleVisible;

  // TODO: suggestion stuff
};

union DataPathTerm {
  string label;
  // TODO(afergan): Once Uris are supported in FIDL, change this type.
  string schema;
  string mimeType;
  string primitiveType;

  // A rough keyword search. This query term exists to take advantage of
  // indexing within Context Service. Boolean queries can be composed using an
  // expression with multiple terms. Any more sophisticated value matching
  // should be done by the caller on the produced Links.
  string value;
};

enum WildcardTerm { Any, AnyStory, AnyData };

interface ContextSubscriberLinkQueryWatcher {
  OnConditionsTrue(string uuid, ContextSubscriberLink match);
  OnMatchLost(string uuid);
  // TODO(afergan): ContextUpdate.json_value => null;
  // TODO(afergan): Subscription.Pause() ?
};
