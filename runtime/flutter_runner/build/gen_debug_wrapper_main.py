#!/usr/bin/env python
# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
import argparse
import os
import re
import sys
def main():
  parser = argparse.ArgumentParser(
    sys.argv[0],
    description="Generate main file for Fuchsia dart test")
  parser.add_argument("--out",
                      help="Path to .dart file to generate",
                      required=True)
  parser.add_argument("--main-dart",
                      help="Path to main.dart file to import",
                      required=True)
  args = parser.parse_args()
  out_dir = os.path.dirname(args.out)
  assert os.path.isfile(os.path.join(os.path.dirname(args.out), args.main_dart))
  outfile = open(args.out, 'w')

  # Ignores relative lib imports due to a few modules that complain about
  # this. It is also possible that a future may be unawaited given that main
  # may not always be synchronous across all functions.
  outfile.write('''// Generated by ''')
  outfile.write(os.path.basename(__file__))
  outfile.write('''


// ignore_for_file: directives_ordering
// ignore_for_file: avoid_relative_lib_imports
// ignore_for_file: unawaited_futures
import 'dart:async';

import 'package:fidl/fidl.dart';

import 'package:fidl_fuchsia_sys/fidl.dart';
import 'package:fidl_fuchsia_testing_runner/fidl.dart';
import 'package:flutter_driver/driver_extension.dart';
import 'package:lib.app.dart/app.dart';
import 'package:lib.module.dart/module.dart';
''')
  outfile.write("import '%s' as flutter_app_main;\n" % args.main_dart)
  outfile.write('''
void main(List<String> args) async {

  assert(await (() async {
    final StartupContext startupContext = new StartupContext.fromStartupInfo();
    final ServiceProviderProxy envServices = startupContext.environmentServices;
    final TestRunnerProxy testRunner = new TestRunnerProxy();
    final ModuleContextClient moduleContext = new ModuleContextClient();
    connectToService(envServices, moduleContext.proxy.ctrl);
    try {
      connectToService(envServices, testRunner.ctrl);
    } on Exception catch (e) {
      // TODO(awdavies): Use the logger instead.
      print(e.toString());
    }
    final Completer<Null> completer = new Completer<Null>();
    testRunner.ctrl.error.then((ProxyError err) {
      if (!completer.isCompleted) {
        completer.completeError(err);
      }
    });
    testRunner.done(completer.complete);
    await completer.future.timeout(
        const Duration(seconds: 5)).then((_) {

      enableFlutterDriverExtension();
      // TODO(awdavies): Use the logger instead.
      print('flutter driver extensions enabled.');
    }, onError: (_) {
      // TODO(awdavies): Use the logger instead.
      // Noop.
      print('flutter driver extensions not enabled.');
    });
    // Always return true so that the assert succeeds.
    return true;
  }()));
  var res = (flutter_app_main.main as dynamic)();
  if (res != null && res is Future) {
    await res;
  }
}
''')
  outfile.close()

if __name__ == '__main__':
  main()

