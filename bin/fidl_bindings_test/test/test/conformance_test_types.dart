// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.
// WARNING: This file is machine generated by fidlgen.

library fidl_conformance_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references

enum SimpleUnionTag {
  i32,
  i64,
  s,
  os,
  str,
}
class SimpleUnion extends $fidl.Union {

  const SimpleUnion.withI32(int value)
    : _data = value, _tag = SimpleUnionTag.i32;

  const SimpleUnion.withI64(int value)
    : _data = value, _tag = SimpleUnionTag.i64;

  const SimpleUnion.withS(Int64Struct value)
    : _data = value, _tag = SimpleUnionTag.s;

  const SimpleUnion.withOs(Int64Struct value)
    : _data = value, _tag = SimpleUnionTag.os;

  const SimpleUnion.withStr(String value)
    : _data = value, _tag = SimpleUnionTag.str;

  SimpleUnion._(SimpleUnionTag tag, Object data) : _tag = tag, _data = data;

  final SimpleUnionTag _tag;
  final _data;
  int get i32 {
    if (_tag != SimpleUnionTag.i32) {
      return null;
    }
    return _data;
  }
  int get i64 {
    if (_tag != SimpleUnionTag.i64) {
      return null;
    }
    return _data;
  }
  Int64Struct get s {
    if (_tag != SimpleUnionTag.s) {
      return null;
    }
    return _data;
  }
  Int64Struct get os {
    if (_tag != SimpleUnionTag.os) {
      return null;
    }
    return _data;
  }
  String get str {
    if (_tag != SimpleUnionTag.str) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case SimpleUnionTag.i32:
        return r'SimpleUnion.i32($i32)';
      case SimpleUnionTag.i64:
        return r'SimpleUnion.i64($i64)';
      case SimpleUnionTag.s:
        return r'SimpleUnion.s($s)';
      case SimpleUnionTag.os:
        return r'SimpleUnion.os($os)';
      case SimpleUnionTag.str:
        return r'SimpleUnion.str($str)';
      default:
        return null;
    }
  }

  SimpleUnionTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  SimpleUnionTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static SimpleUnion _ctor(int index, Object data) {
    return SimpleUnion._(SimpleUnionTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<SimpleUnion> kSimpleUnion_Type = $fidl.UnionType<SimpleUnion>(
  encodedSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 8),
    $fidl.MemberType<Int64Struct>(type: kInt64Struct_Type, offset: 8),
    $fidl.MemberType<Int64Struct>(type: $fidl.PointerType<Int64Struct>(element: kInt64Struct_Type), offset: 8),
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 8),
  ],
  ctor: SimpleUnion._ctor,
);

enum UnionWithEmptyStructTag {
  s,
  s2,
}
class UnionWithEmptyStruct extends $fidl.Union {

  const UnionWithEmptyStruct.withS(EmptyStruct value)
    : _data = value, _tag = UnionWithEmptyStructTag.s;

  const UnionWithEmptyStruct.withS2(EmptyStruct value)
    : _data = value, _tag = UnionWithEmptyStructTag.s2;

  UnionWithEmptyStruct._(UnionWithEmptyStructTag tag, Object data) : _tag = tag, _data = data;

  final UnionWithEmptyStructTag _tag;
  final _data;
  EmptyStruct get s {
    if (_tag != UnionWithEmptyStructTag.s) {
      return null;
    }
    return _data;
  }
  EmptyStruct get s2 {
    if (_tag != UnionWithEmptyStructTag.s2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case UnionWithEmptyStructTag.s:
        return r'UnionWithEmptyStruct.s($s)';
      case UnionWithEmptyStructTag.s2:
        return r'UnionWithEmptyStruct.s2($s2)';
      default:
        return null;
    }
  }

  UnionWithEmptyStructTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  UnionWithEmptyStructTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static UnionWithEmptyStruct _ctor(int index, Object data) {
    return UnionWithEmptyStruct._(UnionWithEmptyStructTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionWithEmptyStruct> kUnionWithEmptyStruct_Type = $fidl.UnionType<UnionWithEmptyStruct>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<EmptyStruct>(type: kEmptyStruct_Type, offset: 8),
    $fidl.MemberType<EmptyStruct>(type: $fidl.PointerType<EmptyStruct>(element: kEmptyStruct_Type), offset: 8),
  ],
  ctor: UnionWithEmptyStruct._ctor,
);

enum IpAddressConfigTag {
  paddingSize24Align4,
  dhcp,
}
class IpAddressConfig extends $fidl.Union {

  const IpAddressConfig.withPaddingSize24Align4(Uint32List value)
    : _data = value, _tag = IpAddressConfigTag.paddingSize24Align4;

  const IpAddressConfig.withDhcp(bool value)
    : _data = value, _tag = IpAddressConfigTag.dhcp;

  IpAddressConfig._(IpAddressConfigTag tag, Object data) : _tag = tag, _data = data;

  final IpAddressConfigTag _tag;
  final _data;
  Uint32List get paddingSize24Align4 {
    if (_tag != IpAddressConfigTag.paddingSize24Align4) {
      return null;
    }
    return _data;
  }
  bool get dhcp {
    if (_tag != IpAddressConfigTag.dhcp) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case IpAddressConfigTag.paddingSize24Align4:
        return r'IpAddressConfig.paddingSize24Align4($paddingSize24Align4)';
      case IpAddressConfigTag.dhcp:
        return r'IpAddressConfig.dhcp($dhcp)';
      default:
        return null;
    }
  }

  IpAddressConfigTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  IpAddressConfigTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static IpAddressConfig _ctor(int index, Object data) {
    return IpAddressConfig._(IpAddressConfigTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<IpAddressConfig> kIpAddressConfig_Type = $fidl.UnionType<IpAddressConfig>(
  encodedSize: 28,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Uint32List>(type: $fidl.ArrayType<Uint32List>(element: $fidl.Uint32Type(), elementCount: 6), offset: 4),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 4),
  ],
  ctor: IpAddressConfig._ctor,
);

enum SampleXUnionTag {
  u, // 0x389c56b2
  su, // 0x792f4f1d
  st, // 0x21de8d5
}

const Map<int, SampleXUnionTag> _SampleXUnionTag_map = {
  949769906: SampleXUnionTag.u,
  2033143581: SampleXUnionTag.su,
  35514581: SampleXUnionTag.st,
};


class SampleXUnion extends $fidl.XUnion {

  const SampleXUnion.withU(int value)
    : _ordinal = 949769906, _data = value;

  const SampleXUnion.withSu(SimpleUnion value)
    : _ordinal = 2033143581, _data = value;

  const SampleXUnion.withSt(SimpleTable value)
    : _ordinal = 35514581, _data = value;

  SampleXUnion._(int ordinal, Object data) : _ordinal = ordinal, _data = data;

  final int _ordinal;
  final _data;

  SampleXUnionTag get $tag => _SampleXUnionTag_map[_ordinal];


  int get u {
    if (_ordinal != 949769906) {
      return null;
    }
    return _data;
  }
  SimpleUnion get su {
    if (_ordinal != 2033143581) {
      return null;
    }
    return _data;
  }
  SimpleTable get st {
    if (_ordinal != 35514581) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 949769906:
        return 'SampleXUnion.u($u)';
      case 2033143581:
        return 'SampleXUnion.su($su)';
      case 35514581:
        return 'SampleXUnion.st($st)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static SampleXUnion _ctor(int ordinal, Object data) {
    return SampleXUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<SampleXUnion> kSampleXUnion_Type = $fidl.XUnionType<SampleXUnion>(
  encodedSize: 24,
  members: <int, $fidl.FidlType>{
    949769906: $fidl.Uint32Type(),
    2033143581: kSimpleUnion_Type,
    35514581: kSimpleTable_Type,
  },
  ctor: SampleXUnion._ctor,
);
const $fidl.XUnionType<SampleXUnion> kSampleXUnion_OptType = $fidl.XUnionType<SampleXUnion>(
encodedSize: 24,
members: <int, $fidl.FidlType>{
    949769906: $fidl.Uint32Type(),
    2033143581: kSimpleUnion_Type,
    35514581: kSimpleTable_Type,
  },
ctor: SampleXUnion._ctor,
nullable: true,
);

enum SampleStrictXUnionTag {
  u, // 0x8e2ea72
  su, // 0x27f3a73b
  st, // 0x372354ef
}

const Map<int, SampleStrictXUnionTag> _SampleStrictXUnionTag_map = {
  149088882: SampleStrictXUnionTag.u,
  670279483: SampleStrictXUnionTag.su,
  925062383: SampleStrictXUnionTag.st,
};


class SampleStrictXUnion extends $fidl.XUnion {

  const SampleStrictXUnion.withU(int value)
    : _ordinal = 149088882, _data = value;

  const SampleStrictXUnion.withSu(SimpleUnion value)
    : _ordinal = 670279483, _data = value;

  const SampleStrictXUnion.withSt(SimpleTable value)
    : _ordinal = 925062383, _data = value;

  SampleStrictXUnion._(int ordinal, Object data) : _ordinal = ordinal, _data = data;

  final int _ordinal;
  final _data;

  SampleStrictXUnionTag get $tag => _SampleStrictXUnionTag_map[_ordinal];


  int get u {
    if (_ordinal != 149088882) {
      return null;
    }
    return _data;
  }
  SimpleUnion get su {
    if (_ordinal != 670279483) {
      return null;
    }
    return _data;
  }
  SimpleTable get st {
    if (_ordinal != 925062383) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 149088882:
        return 'SampleStrictXUnion.u($u)';
      case 670279483:
        return 'SampleStrictXUnion.su($su)';
      case 925062383:
        return 'SampleStrictXUnion.st($st)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static SampleStrictXUnion _ctor(int ordinal, Object data) {
    return SampleStrictXUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<SampleStrictXUnion> kSampleStrictXUnion_Type = $fidl.XUnionType<SampleStrictXUnion>(
  encodedSize: 24,
  members: <int, $fidl.FidlType>{
    149088882: $fidl.Uint32Type(),
    670279483: kSimpleUnion_Type,
    925062383: kSimpleTable_Type,
  },
  ctor: SampleStrictXUnion._ctor,
);
const $fidl.XUnionType<SampleStrictXUnion> kSampleStrictXUnion_OptType = $fidl.XUnionType<SampleStrictXUnion>(
encodedSize: 24,
members: <int, $fidl.FidlType>{
    149088882: $fidl.Uint32Type(),
    670279483: kSimpleUnion_Type,
    925062383: kSimpleTable_Type,
  },
ctor: SampleStrictXUnion._ctor,
nullable: true,
);

enum XUnionWithEmptyStructTag {
  s, // 0x7499e0fe
}

const Map<int, XUnionWithEmptyStructTag> _XUnionWithEmptyStructTag_map = {
  1956241662: XUnionWithEmptyStructTag.s,
};


class XUnionWithEmptyStruct extends $fidl.XUnion {

  const XUnionWithEmptyStruct.withS(EmptyStruct value)
    : _ordinal = 1956241662, _data = value;

  XUnionWithEmptyStruct._(int ordinal, Object data) : _ordinal = ordinal, _data = data;

  final int _ordinal;
  final _data;

  XUnionWithEmptyStructTag get $tag => _XUnionWithEmptyStructTag_map[_ordinal];


  EmptyStruct get s {
    if (_ordinal != 1956241662) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1956241662:
        return 'XUnionWithEmptyStruct.s($s)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static XUnionWithEmptyStruct _ctor(int ordinal, Object data) {
    return XUnionWithEmptyStruct._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<XUnionWithEmptyStruct> kXUnionWithEmptyStruct_Type = $fidl.XUnionType<XUnionWithEmptyStruct>(
  encodedSize: 24,
  members: <int, $fidl.FidlType>{
    1956241662: kEmptyStruct_Type,
  },
  ctor: XUnionWithEmptyStruct._ctor,
);
const $fidl.XUnionType<XUnionWithEmptyStruct> kXUnionWithEmptyStruct_OptType = $fidl.XUnionType<XUnionWithEmptyStruct>(
encodedSize: 24,
members: <int, $fidl.FidlType>{
    1956241662: kEmptyStruct_Type,
  },
ctor: XUnionWithEmptyStruct._ctor,
nullable: true,
);


class ThreeByte extends $fidl.Struct {
  const ThreeByte({
    @required this.elem1,
    @required this.elem2,
    @required this.elem3,
  });
  ThreeByte.clone(ThreeByte $orig, {
  int elem1,
  int elem2,
  int elem3,
  }) : this(
      elem1: elem1 ?? $orig.elem1,
      elem2: elem2 ?? $orig.elem2,
      elem3: elem3 ?? $orig.elem3,
    );


  

  ThreeByte._(List<Object> argv)
    : elem1 = argv[0],
      elem2 = argv[1],
      elem3 = argv[2];
  final int elem1;
  final int elem2;
  final int elem3;

  @override
  List<Object> get $fields {
    return <Object>[
      elem1,
      elem2,
      elem3,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'ThreeByte' r'(elem1: ' + elem1.toString() + r', elem2: ' + elem2.toString() + r', elem3: ' + elem3.toString() + r')';
  }

  static ThreeByte _ctor(List<Object> argv) => ThreeByte._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ThreeByte> kThreeByte_Type = $fidl.StructType<ThreeByte>(
  encodedSize: 3,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 1),
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 2),
  ],
  ctor: ThreeByte._ctor,
);


class FiveByte extends $fidl.Struct {
  const FiveByte({
    @required this.elem1,
    @required this.elem2,
  });
  FiveByte.clone(FiveByte $orig, {
  int elem1,
  int elem2,
  }) : this(
      elem1: elem1 ?? $orig.elem1,
      elem2: elem2 ?? $orig.elem2,
    );


  

  FiveByte._(List<Object> argv)
    : elem1 = argv[0],
      elem2 = argv[1];
  final int elem1;
  final int elem2;

  @override
  List<Object> get $fields {
    return <Object>[
      elem1,
      elem2,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'FiveByte' r'(elem1: ' + elem1.toString() + r', elem2: ' + elem2.toString() + r')';
  }

  static FiveByte _ctor(List<Object> argv) => FiveByte._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<FiveByte> kFiveByte_Type = $fidl.StructType<FiveByte>(
  encodedSize: 8,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 4),
  ],
  ctor: FiveByte._ctor,
);


class ThreeByteInStruct extends $fidl.Struct {
  const ThreeByteInStruct({
    @required this.elem1,
    @required this.elem2,
    @required this.elem3,
  });
  ThreeByteInStruct.clone(ThreeByteInStruct $orig, {
  ThreeByte elem1,
  ThreeByte elem2,
  ThreeByte elem3,
  }) : this(
      elem1: elem1 ?? $orig.elem1,
      elem2: elem2 ?? $orig.elem2,
      elem3: elem3 ?? $orig.elem3,
    );


  

  ThreeByteInStruct._(List<Object> argv)
    : elem1 = argv[0],
      elem2 = argv[1],
      elem3 = argv[2];
  final ThreeByte elem1;
  final ThreeByte elem2;
  final ThreeByte elem3;

  @override
  List<Object> get $fields {
    return <Object>[
      elem1,
      elem2,
      elem3,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'ThreeByteInStruct' r'(elem1: ' + elem1.toString() + r', elem2: ' + elem2.toString() + r', elem3: ' + elem3.toString() + r')';
  }

  static ThreeByteInStruct _ctor(List<Object> argv) => ThreeByteInStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ThreeByteInStruct> kThreeByteInStruct_Type = $fidl.StructType<ThreeByteInStruct>(
  encodedSize: 9,
  members: <$fidl.MemberType>[
    $fidl.MemberType<ThreeByte>(type: kThreeByte_Type, offset: 0),
    $fidl.MemberType<ThreeByte>(type: kThreeByte_Type, offset: 3),
    $fidl.MemberType<ThreeByte>(type: kThreeByte_Type, offset: 6),
  ],
  ctor: ThreeByteInStruct._ctor,
);


class FiveByteInStruct extends $fidl.Struct {
  const FiveByteInStruct({
    @required this.elem1,
    @required this.elem2,
    @required this.elem3,
  });
  FiveByteInStruct.clone(FiveByteInStruct $orig, {
  FiveByte elem1,
  FiveByte elem2,
  FiveByte elem3,
  }) : this(
      elem1: elem1 ?? $orig.elem1,
      elem2: elem2 ?? $orig.elem2,
      elem3: elem3 ?? $orig.elem3,
    );


  

  FiveByteInStruct._(List<Object> argv)
    : elem1 = argv[0],
      elem2 = argv[1],
      elem3 = argv[2];
  final FiveByte elem1;
  final FiveByte elem2;
  final FiveByte elem3;

  @override
  List<Object> get $fields {
    return <Object>[
      elem1,
      elem2,
      elem3,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'FiveByteInStruct' r'(elem1: ' + elem1.toString() + r', elem2: ' + elem2.toString() + r', elem3: ' + elem3.toString() + r')';
  }

  static FiveByteInStruct _ctor(List<Object> argv) => FiveByteInStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<FiveByteInStruct> kFiveByteInStruct_Type = $fidl.StructType<FiveByteInStruct>(
  encodedSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<FiveByte>(type: kFiveByte_Type, offset: 0),
    $fidl.MemberType<FiveByte>(type: kFiveByte_Type, offset: 8),
    $fidl.MemberType<FiveByte>(type: kFiveByte_Type, offset: 16),
  ],
  ctor: FiveByteInStruct._ctor,
);


class ThreeByteInVector extends $fidl.Struct {
  const ThreeByteInVector({
    @required this.elems,
  });
  ThreeByteInVector.clone(ThreeByteInVector $orig, {
  List<ThreeByte> elems,
  }) : this(
      elems: elems ?? $orig.elems,
    );


  

  ThreeByteInVector._(List<Object> argv)
    : elems = argv[0];
  final List<ThreeByte> elems;

  @override
  List<Object> get $fields {
    return <Object>[
      elems,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'ThreeByteInVector' r'(elems: ' + elems.toString() + r')';
  }

  static ThreeByteInVector _ctor(List<Object> argv) => ThreeByteInVector._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ThreeByteInVector> kThreeByteInVector_Type = $fidl.StructType<ThreeByteInVector>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<List<ThreeByte>>(type: $fidl.VectorType<List<ThreeByte>>(element: kThreeByte_Type, maybeElementCount: null, nullable: false), offset: 0),
  ],
  ctor: ThreeByteInVector._ctor,
);


class FiveByteInVector extends $fidl.Struct {
  const FiveByteInVector({
    @required this.elems,
  });
  FiveByteInVector.clone(FiveByteInVector $orig, {
  List<FiveByte> elems,
  }) : this(
      elems: elems ?? $orig.elems,
    );


  

  FiveByteInVector._(List<Object> argv)
    : elems = argv[0];
  final List<FiveByte> elems;

  @override
  List<Object> get $fields {
    return <Object>[
      elems,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'FiveByteInVector' r'(elems: ' + elems.toString() + r')';
  }

  static FiveByteInVector _ctor(List<Object> argv) => FiveByteInVector._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<FiveByteInVector> kFiveByteInVector_Type = $fidl.StructType<FiveByteInVector>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<List<FiveByte>>(type: $fidl.VectorType<List<FiveByte>>(element: kFiveByte_Type, maybeElementCount: null, nullable: false), offset: 0),
  ],
  ctor: FiveByteInVector._ctor,
);


class ThreeByteInArray extends $fidl.Struct {
  const ThreeByteInArray({
    @required this.elems,
  });
  ThreeByteInArray.clone(ThreeByteInArray $orig, {
  List<ThreeByte> elems,
  }) : this(
      elems: elems ?? $orig.elems,
    );


  

  ThreeByteInArray._(List<Object> argv)
    : elems = argv[0];
  final List<ThreeByte> elems;

  @override
  List<Object> get $fields {
    return <Object>[
      elems,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'ThreeByteInArray' r'(elems: ' + elems.toString() + r')';
  }

  static ThreeByteInArray _ctor(List<Object> argv) => ThreeByteInArray._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ThreeByteInArray> kThreeByteInArray_Type = $fidl.StructType<ThreeByteInArray>(
  encodedSize: 9,
  members: <$fidl.MemberType>[
    $fidl.MemberType<List<ThreeByte>>(type: $fidl.ArrayType<List<ThreeByte>>(element: kThreeByte_Type, elementCount: 3), offset: 0),
  ],
  ctor: ThreeByteInArray._ctor,
);


class FiveByteInArray extends $fidl.Struct {
  const FiveByteInArray({
    @required this.elems,
  });
  FiveByteInArray.clone(FiveByteInArray $orig, {
  List<FiveByte> elems,
  }) : this(
      elems: elems ?? $orig.elems,
    );


  

  FiveByteInArray._(List<Object> argv)
    : elems = argv[0];
  final List<FiveByte> elems;

  @override
  List<Object> get $fields {
    return <Object>[
      elems,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'FiveByteInArray' r'(elems: ' + elems.toString() + r')';
  }

  static FiveByteInArray _ctor(List<Object> argv) => FiveByteInArray._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<FiveByteInArray> kFiveByteInArray_Type = $fidl.StructType<FiveByteInArray>(
  encodedSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<List<FiveByte>>(type: $fidl.ArrayType<List<FiveByte>>(element: kFiveByte_Type, elementCount: 3), offset: 0),
  ],
  ctor: FiveByteInArray._ctor,
);


class Int64Struct extends $fidl.Struct {
  const Int64Struct({
    @required this.x,
  });
  Int64Struct.clone(Int64Struct $orig, {
  int x,
  }) : this(
      x: x ?? $orig.x,
    );


  

  Int64Struct._(List<Object> argv)
    : x = argv[0];
  final int x;

  @override
  List<Object> get $fields {
    return <Object>[
      x,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Int64Struct' r'(x: ' + x.toString() + r')';
  }

  static Int64Struct _ctor(List<Object> argv) => Int64Struct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Int64Struct> kInt64Struct_Type = $fidl.StructType<Int64Struct>(
  encodedSize: 8,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  ctor: Int64Struct._ctor,
);


class TestInlineXUnionInStruct extends $fidl.Struct {
  const TestInlineXUnionInStruct({
    @required this.before,
    @required this.xu,
    @required this.after,
  });
  TestInlineXUnionInStruct.clone(TestInlineXUnionInStruct $orig, {
  String before,
  SampleXUnion xu,
  String after,
  }) : this(
      before: before ?? $orig.before,
      xu: xu ?? $orig.xu,
      after: after ?? $orig.after,
    );


  

  TestInlineXUnionInStruct._(List<Object> argv)
    : before = argv[0],
      xu = argv[1],
      after = argv[2];
  final String before;
  final SampleXUnion xu;
  final String after;

  @override
  List<Object> get $fields {
    return <Object>[
      before,
      xu,
      after,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'TestInlineXUnionInStruct' r'(before: ' + before.toString() + r', xu: ' + xu.toString() + r', after: ' + after.toString() + r')';
  }

  static TestInlineXUnionInStruct _ctor(List<Object> argv) => TestInlineXUnionInStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TestInlineXUnionInStruct> kTestInlineXUnionInStruct_Type = $fidl.StructType<TestInlineXUnionInStruct>(
  encodedSize: 56,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<SampleXUnion>(type: kSampleXUnion_Type, offset: 16),
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 40),
  ],
  ctor: TestInlineXUnionInStruct._ctor,
);


class TestOptionalXUnionInStruct extends $fidl.Struct {
  const TestOptionalXUnionInStruct({
    @required this.before,
    this.xu,
    @required this.after,
  });
  TestOptionalXUnionInStruct.clone(TestOptionalXUnionInStruct $orig, {
  String before,
  SampleXUnion xu,
  String after,
  }) : this(
      before: before ?? $orig.before,
      xu: xu ?? $orig.xu,
      after: after ?? $orig.after,
    );


  
    TestOptionalXUnionInStruct.cloneWithout(TestOptionalXUnionInStruct $orig, {
        
        bool xu,
        
    }) : this(
        
          before: $orig.before,
        
        
          xu: xu ? null : $orig.xu,
        
        
          after: $orig.after,
        
      );
  

  TestOptionalXUnionInStruct._(List<Object> argv)
    : before = argv[0],
      xu = argv[1],
      after = argv[2];
  final String before;
  final SampleXUnion xu;
  final String after;

  @override
  List<Object> get $fields {
    return <Object>[
      before,
      xu,
      after,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'TestOptionalXUnionInStruct' r'(before: ' + before.toString() + r', xu: ' + xu.toString() + r', after: ' + after.toString() + r')';
  }

  static TestOptionalXUnionInStruct _ctor(List<Object> argv) => TestOptionalXUnionInStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TestOptionalXUnionInStruct> kTestOptionalXUnionInStruct_Type = $fidl.StructType<TestOptionalXUnionInStruct>(
  encodedSize: 56,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<SampleXUnion>(type: kSampleXUnion_OptType, offset: 16),
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 40),
  ],
  ctor: TestOptionalXUnionInStruct._ctor,
);


class TestStrictXUnionInStruct extends $fidl.Struct {
  const TestStrictXUnionInStruct({
    @required this.xu,
  });
  TestStrictXUnionInStruct.clone(TestStrictXUnionInStruct $orig, {
  SampleStrictXUnion xu,
  }) : this(
      xu: xu ?? $orig.xu,
    );


  

  TestStrictXUnionInStruct._(List<Object> argv)
    : xu = argv[0];
  final SampleStrictXUnion xu;

  @override
  List<Object> get $fields {
    return <Object>[
      xu,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'TestStrictXUnionInStruct' r'(xu: ' + xu.toString() + r')';
  }

  static TestStrictXUnionInStruct _ctor(List<Object> argv) => TestStrictXUnionInStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TestStrictXUnionInStruct> kTestStrictXUnionInStruct_Type = $fidl.StructType<TestStrictXUnionInStruct>(
  encodedSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<SampleStrictXUnion>(type: kSampleStrictXUnion_Type, offset: 0),
  ],
  ctor: TestStrictXUnionInStruct._ctor,
);


class Length2StringWrapper extends $fidl.Struct {
  const Length2StringWrapper({
    @required this.length2String,
  });
  Length2StringWrapper.clone(Length2StringWrapper $orig, {
  String length2String,
  }) : this(
      length2String: length2String ?? $orig.length2String,
    );


  

  Length2StringWrapper._(List<Object> argv)
    : length2String = argv[0];
  final String length2String;

  @override
  List<Object> get $fields {
    return <Object>[
      length2String,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Length2StringWrapper' r'(length2String: ' + length2String.toString() + r')';
  }

  static Length2StringWrapper _ctor(List<Object> argv) => Length2StringWrapper._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Length2StringWrapper> kLength2StringWrapper_Type = $fidl.StructType<Length2StringWrapper>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: 2, nullable: false), offset: 0),
  ],
  ctor: Length2StringWrapper._ctor,
);


class StringWrapper extends $fidl.Struct {
  const StringWrapper({
    @required this.str,
  });
  StringWrapper.clone(StringWrapper $orig, {
  String str,
  }) : this(
      str: str ?? $orig.str,
    );


  

  StringWrapper._(List<Object> argv)
    : str = argv[0];
  final String str;

  @override
  List<Object> get $fields {
    return <Object>[
      str,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StringWrapper' r'(str: ' + str.toString() + r')';
  }

  static StringWrapper _ctor(List<Object> argv) => StringWrapper._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StringWrapper> kStringWrapper_Type = $fidl.StructType<StringWrapper>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
  ],
  ctor: StringWrapper._ctor,
);


class StructWithOptionals extends $fidl.Struct {
  const StructWithOptionals({
    @required this.s,
    this.s2,
    @required this.t,
    @required this.xu,
    this.xu2,
    @required this.u,
    this.u2,
  });
  StructWithOptionals.clone(StructWithOptionals $orig, {
  EmptyStruct s,
  EmptyStruct s2,
  TableWithEmptyStruct t,
  XUnionWithEmptyStruct xu,
  XUnionWithEmptyStruct xu2,
  UnionWithEmptyStruct u,
  UnionWithEmptyStruct u2,
  }) : this(
      s: s ?? $orig.s,
      s2: s2 ?? $orig.s2,
      t: t ?? $orig.t,
      xu: xu ?? $orig.xu,
      xu2: xu2 ?? $orig.xu2,
      u: u ?? $orig.u,
      u2: u2 ?? $orig.u2,
    );


  
    StructWithOptionals.cloneWithout(StructWithOptionals $orig, {
        
        bool s2,
        
        
        bool xu2,
        
        bool u2,
    }) : this(
        
          s: $orig.s,
        
        
          s2: s2 ? null : $orig.s2,
        
        
          t: $orig.t,
        
        
          xu: $orig.xu,
        
        
          xu2: xu2 ? null : $orig.xu2,
        
        
          u: $orig.u,
        
        
          u2: u2 ? null : $orig.u2,
        
      );
  

  StructWithOptionals._(List<Object> argv)
    : s = argv[0],
      s2 = argv[1],
      t = argv[2],
      xu = argv[3],
      xu2 = argv[4],
      u = argv[5],
      u2 = argv[6];
  final EmptyStruct s;
  final EmptyStruct s2;
  final TableWithEmptyStruct t;
  final XUnionWithEmptyStruct xu;
  final XUnionWithEmptyStruct xu2;
  final UnionWithEmptyStruct u;
  final UnionWithEmptyStruct u2;

  @override
  List<Object> get $fields {
    return <Object>[
      s,
      s2,
      t,
      xu,
      xu2,
      u,
      u2,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructWithOptionals' r'(s: ' + s.toString() + r', s2: ' + s2.toString() + r', t: ' + t.toString() + r', xu: ' + xu.toString() + r', xu2: ' + xu2.toString() + r', u: ' + u.toString() + r', u2: ' + u2.toString() + r')';
  }

  static StructWithOptionals _ctor(List<Object> argv) => StructWithOptionals._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructWithOptionals> kStructWithOptionals_Type = $fidl.StructType<StructWithOptionals>(
  encodedSize: 104,
  members: <$fidl.MemberType>[
    $fidl.MemberType<EmptyStruct>(type: kEmptyStruct_Type, offset: 0),
    $fidl.MemberType<EmptyStruct>(type: $fidl.PointerType<EmptyStruct>(element: kEmptyStruct_Type), offset: 8),
    $fidl.MemberType<TableWithEmptyStruct>(type: kTableWithEmptyStruct_Type, offset: 16),
    $fidl.MemberType<XUnionWithEmptyStruct>(type: kXUnionWithEmptyStruct_Type, offset: 32),
    $fidl.MemberType<XUnionWithEmptyStruct>(type: kXUnionWithEmptyStruct_OptType, offset: 56),
    $fidl.MemberType<UnionWithEmptyStruct>(type: kUnionWithEmptyStruct_Type, offset: 80),
    $fidl.MemberType<UnionWithEmptyStruct>(type: $fidl.PointerType<UnionWithEmptyStruct>(element: kUnionWithEmptyStruct_Type), offset: 96),
  ],
  ctor: StructWithOptionals._ctor,
);


class TestXUnionInTable extends $fidl.Struct {
  const TestXUnionInTable({
    @required this.value,
  });
  TestXUnionInTable.clone(TestXUnionInTable $orig, {
  XUnionInTable value,
  }) : this(
      value: value ?? $orig.value,
    );


  

  TestXUnionInTable._(List<Object> argv)
    : value = argv[0];
  final XUnionInTable value;

  @override
  List<Object> get $fields {
    return <Object>[
      value,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'TestXUnionInTable' r'(value: ' + value.toString() + r')';
  }

  static TestXUnionInTable _ctor(List<Object> argv) => TestXUnionInTable._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TestXUnionInTable> kTestXUnionInTable_Type = $fidl.StructType<TestXUnionInTable>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<XUnionInTable>(type: kXUnionInTable_Type, offset: 0),
  ],
  ctor: TestXUnionInTable._ctor,
);


class InterfaceConfig extends $fidl.Struct {
  const InterfaceConfig({
    @required this.name,
    @required this.ipAddressConfig,
  });
  InterfaceConfig.clone(InterfaceConfig $orig, {
  String name,
  IpAddressConfig ipAddressConfig,
  }) : this(
      name: name ?? $orig.name,
      ipAddressConfig: ipAddressConfig ?? $orig.ipAddressConfig,
    );


  

  InterfaceConfig._(List<Object> argv)
    : name = argv[0],
      ipAddressConfig = argv[1];
  final String name;
  final IpAddressConfig ipAddressConfig;

  @override
  List<Object> get $fields {
    return <Object>[
      name,
      ipAddressConfig,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'InterfaceConfig' r'(name: ' + name.toString() + r', ipAddressConfig: ' + ipAddressConfig.toString() + r')';
  }

  static InterfaceConfig _ctor(List<Object> argv) => InterfaceConfig._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<InterfaceConfig> kInterfaceConfig_Type = $fidl.StructType<InterfaceConfig>(
  encodedSize: 48,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<IpAddressConfig>(type: kIpAddressConfig_Type, offset: 16),
  ],
  ctor: InterfaceConfig._ctor,
);


class TestAddEthernetDeviceRequest extends $fidl.Struct {
  const TestAddEthernetDeviceRequest({
    @required this.topologicalPath,
    @required this.config,
    @required this.thisShouldBeAHandle,
  });
  TestAddEthernetDeviceRequest.clone(TestAddEthernetDeviceRequest $orig, {
  String topologicalPath,
  InterfaceConfig config,
  int thisShouldBeAHandle,
  }) : this(
      topologicalPath: topologicalPath ?? $orig.topologicalPath,
      config: config ?? $orig.config,
      thisShouldBeAHandle: thisShouldBeAHandle ?? $orig.thisShouldBeAHandle,
    );


  

  TestAddEthernetDeviceRequest._(List<Object> argv)
    : topologicalPath = argv[0],
      config = argv[1],
      thisShouldBeAHandle = argv[2];
  final String topologicalPath;
  final InterfaceConfig config;
  final int thisShouldBeAHandle;

  @override
  List<Object> get $fields {
    return <Object>[
      topologicalPath,
      config,
      thisShouldBeAHandle,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'TestAddEthernetDeviceRequest' r'(topologicalPath: ' + topologicalPath.toString() + r', config: ' + config.toString() + r', thisShouldBeAHandle: ' + thisShouldBeAHandle.toString() + r')';
  }

  static TestAddEthernetDeviceRequest _ctor(List<Object> argv) => TestAddEthernetDeviceRequest._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TestAddEthernetDeviceRequest> kTestAddEthernetDeviceRequest_Type = $fidl.StructType<TestAddEthernetDeviceRequest>(
  encodedSize: 72,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<InterfaceConfig>(type: kInterfaceConfig_Type, offset: 16),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 64),
  ],
  ctor: TestAddEthernetDeviceRequest._ctor,
);


class NodeAttributes extends $fidl.Struct {
  const NodeAttributes({
    @required this.mode,
    @required this.id,
    @required this.contentSize,
    @required this.storageSize,
    @required this.linkCount,
    @required this.creationTime,
    @required this.modificationTime,
  });
  NodeAttributes.clone(NodeAttributes $orig, {
  int mode,
  int id,
  int contentSize,
  int storageSize,
  int linkCount,
  int creationTime,
  int modificationTime,
  }) : this(
      mode: mode ?? $orig.mode,
      id: id ?? $orig.id,
      contentSize: contentSize ?? $orig.contentSize,
      storageSize: storageSize ?? $orig.storageSize,
      linkCount: linkCount ?? $orig.linkCount,
      creationTime: creationTime ?? $orig.creationTime,
      modificationTime: modificationTime ?? $orig.modificationTime,
    );


  

  NodeAttributes._(List<Object> argv)
    : mode = argv[0],
      id = argv[1],
      contentSize = argv[2],
      storageSize = argv[3],
      linkCount = argv[4],
      creationTime = argv[5],
      modificationTime = argv[6];
  final int mode;
  final int id;
  final int contentSize;
  final int storageSize;
  final int linkCount;
  final int creationTime;
  final int modificationTime;

  @override
  List<Object> get $fields {
    return <Object>[
      mode,
      id,
      contentSize,
      storageSize,
      linkCount,
      creationTime,
      modificationTime,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'NodeAttributes' r'(mode: ' + mode.toString() + r', id: ' + id.toString() + r', contentSize: ' + contentSize.toString() + r', storageSize: ' + storageSize.toString() + r', linkCount: ' + linkCount.toString() + r', creationTime: ' + creationTime.toString() + r', modificationTime: ' + modificationTime.toString() + r')';
  }

  static NodeAttributes _ctor(List<Object> argv) => NodeAttributes._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NodeAttributes> kNodeAttributes_Type = $fidl.StructType<NodeAttributes>(
  encodedSize: 56,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 16),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 24),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 32),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 40),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 48),
  ],
  ctor: NodeAttributes._ctor,
);


class FileGetAttrResponse extends $fidl.Struct {
  const FileGetAttrResponse({
    @required this.s,
    @required this.attributes,
  });
  FileGetAttrResponse.clone(FileGetAttrResponse $orig, {
  int s,
  NodeAttributes attributes,
  }) : this(
      s: s ?? $orig.s,
      attributes: attributes ?? $orig.attributes,
    );


  

  FileGetAttrResponse._(List<Object> argv)
    : s = argv[0],
      attributes = argv[1];
  final int s;
  final NodeAttributes attributes;

  @override
  List<Object> get $fields {
    return <Object>[
      s,
      attributes,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'FileGetAttrResponse' r'(s: ' + s.toString() + r', attributes: ' + attributes.toString() + r')';
  }

  static FileGetAttrResponse _ctor(List<Object> argv) => FileGetAttrResponse._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<FileGetAttrResponse> kFileGetAttrResponse_Type = $fidl.StructType<FileGetAttrResponse>(
  encodedSize: 64,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
    $fidl.MemberType<NodeAttributes>(type: kNodeAttributes_Type, offset: 8),
  ],
  ctor: FileGetAttrResponse._ctor,
);


class EmptyStruct extends $fidl.Struct {
  const EmptyStruct({
    this.reserved: 0x0,
  });
  EmptyStruct.clone(EmptyStruct $orig, {
  int reserved,
  }) : this(
      reserved: reserved ?? $orig.reserved,
    );


  

  EmptyStruct._(List<Object> argv)
    : reserved = argv[0];
  final int reserved;

  @override
  List<Object> get $fields {
    return <Object>[
      reserved,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'EmptyStruct' r'(reserved: ' + reserved.toString() + r')';
  }

  static EmptyStruct _ctor(List<Object> argv) => EmptyStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<EmptyStruct> kEmptyStruct_Type = $fidl.StructType<EmptyStruct>(
  encodedSize: 1,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
  ],
  ctor: EmptyStruct._ctor,
);


class EmptyStructSandwich extends $fidl.Struct {
  const EmptyStructSandwich({
    @required this.before,
    @required this.es,
    @required this.after,
  });
  EmptyStructSandwich.clone(EmptyStructSandwich $orig, {
  String before,
  EmptyStruct es,
  String after,
  }) : this(
      before: before ?? $orig.before,
      es: es ?? $orig.es,
      after: after ?? $orig.after,
    );


  

  EmptyStructSandwich._(List<Object> argv)
    : before = argv[0],
      es = argv[1],
      after = argv[2];
  final String before;
  final EmptyStruct es;
  final String after;

  @override
  List<Object> get $fields {
    return <Object>[
      before,
      es,
      after,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'EmptyStructSandwich' r'(before: ' + before.toString() + r', es: ' + es.toString() + r', after: ' + after.toString() + r')';
  }

  static EmptyStructSandwich _ctor(List<Object> argv) => EmptyStructSandwich._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<EmptyStructSandwich> kEmptyStructSandwich_Type = $fidl.StructType<EmptyStructSandwich>(
  encodedSize: 40,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<EmptyStruct>(type: kEmptyStruct_Type, offset: 16),
    $fidl.MemberType<String>(type: $fidl.StringType(maybeElementCount: null, nullable: false), offset: 24),
  ],
  ctor: EmptyStructSandwich._ctor,
);


class Uint8Uint16Uint32Uint64 extends $fidl.Struct {
  const Uint8Uint16Uint32Uint64({
    @required this.f1,
    @required this.f2,
    @required this.f3,
    @required this.f4,
  });
  Uint8Uint16Uint32Uint64.clone(Uint8Uint16Uint32Uint64 $orig, {
  int f1,
  int f2,
  int f3,
  int f4,
  }) : this(
      f1: f1 ?? $orig.f1,
      f2: f2 ?? $orig.f2,
      f3: f3 ?? $orig.f3,
      f4: f4 ?? $orig.f4,
    );


  

  Uint8Uint16Uint32Uint64._(List<Object> argv)
    : f1 = argv[0],
      f2 = argv[1],
      f3 = argv[2],
      f4 = argv[3];
  final int f1;
  final int f2;
  final int f3;
  final int f4;

  @override
  List<Object> get $fields {
    return <Object>[
      f1,
      f2,
      f3,
      f4,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Uint8Uint16Uint32Uint64' r'(f1: ' + f1.toString() + r', f2: ' + f2.toString() + r', f3: ' + f3.toString() + r', f4: ' + f4.toString() + r')';
  }

  static Uint8Uint16Uint32Uint64 _ctor(List<Object> argv) => Uint8Uint16Uint32Uint64._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Uint8Uint16Uint32Uint64> kUint8Uint16Uint32Uint64_Type = $fidl.StructType<Uint8Uint16Uint32Uint64>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 2),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
  ],
  ctor: Uint8Uint16Uint32Uint64._ctor,
);


class Uint64Uint32Uint16Uint8 extends $fidl.Struct {
  const Uint64Uint32Uint16Uint8({
    @required this.f1,
    @required this.f2,
    @required this.f3,
    @required this.f4,
  });
  Uint64Uint32Uint16Uint8.clone(Uint64Uint32Uint16Uint8 $orig, {
  int f1,
  int f2,
  int f3,
  int f4,
  }) : this(
      f1: f1 ?? $orig.f1,
      f2: f2 ?? $orig.f2,
      f3: f3 ?? $orig.f3,
      f4: f4 ?? $orig.f4,
    );


  

  Uint64Uint32Uint16Uint8._(List<Object> argv)
    : f1 = argv[0],
      f2 = argv[1],
      f3 = argv[2],
      f4 = argv[3];
  final int f1;
  final int f2;
  final int f3;
  final int f4;

  @override
  List<Object> get $fields {
    return <Object>[
      f1,
      f2,
      f3,
      f4,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Uint64Uint32Uint16Uint8' r'(f1: ' + f1.toString() + r', f2: ' + f2.toString() + r', f3: ' + f3.toString() + r', f4: ' + f4.toString() + r')';
  }

  static Uint64Uint32Uint16Uint8 _ctor(List<Object> argv) => Uint64Uint32Uint16Uint8._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Uint64Uint32Uint16Uint8> kUint64Uint32Uint16Uint8_Type = $fidl.StructType<Uint64Uint32Uint16Uint8>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 12),
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 14),
  ],
  ctor: Uint64Uint32Uint16Uint8._ctor,
);


class StructOfSimpleTable extends $fidl.Struct {
  const StructOfSimpleTable({
    @required this.table,
  });
  StructOfSimpleTable.clone(StructOfSimpleTable $orig, {
  SimpleTable table,
  }) : this(
      table: table ?? $orig.table,
    );


  

  StructOfSimpleTable._(List<Object> argv)
    : table = argv[0];
  final SimpleTable table;

  @override
  List<Object> get $fields {
    return <Object>[
      table,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructOfSimpleTable' r'(table: ' + table.toString() + r')';
  }

  static StructOfSimpleTable _ctor(List<Object> argv) => StructOfSimpleTable._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructOfSimpleTable> kStructOfSimpleTable_Type = $fidl.StructType<StructOfSimpleTable>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<SimpleTable>(type: kSimpleTable_Type, offset: 0),
  ],
  ctor: StructOfSimpleTable._ctor,
);


class SimpleTableThenUint64 extends $fidl.Struct {
  const SimpleTableThenUint64({
    @required this.table,
    @required this.number,
  });
  SimpleTableThenUint64.clone(SimpleTableThenUint64 $orig, {
  SimpleTable table,
  int number,
  }) : this(
      table: table ?? $orig.table,
      number: number ?? $orig.number,
    );


  

  SimpleTableThenUint64._(List<Object> argv)
    : table = argv[0],
      number = argv[1];
  final SimpleTable table;
  final int number;

  @override
  List<Object> get $fields {
    return <Object>[
      table,
      number,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'SimpleTableThenUint64' r'(table: ' + table.toString() + r', number: ' + number.toString() + r')';
  }

  static SimpleTableThenUint64 _ctor(List<Object> argv) => SimpleTableThenUint64._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<SimpleTableThenUint64> kSimpleTableThenUint64_Type = $fidl.StructType<SimpleTableThenUint64>(
  encodedSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<SimpleTable>(type: kSimpleTable_Type, offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 16),
  ],
  ctor: SimpleTableThenUint64._ctor,
);


class StructOfTableWithStringAndVector extends $fidl.Struct {
  const StructOfTableWithStringAndVector({
    @required this.table,
  });
  StructOfTableWithStringAndVector.clone(StructOfTableWithStringAndVector $orig, {
  TableWithStringAndVector table,
  }) : this(
      table: table ?? $orig.table,
    );


  

  StructOfTableWithStringAndVector._(List<Object> argv)
    : table = argv[0];
  final TableWithStringAndVector table;

  @override
  List<Object> get $fields {
    return <Object>[
      table,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructOfTableWithStringAndVector' r'(table: ' + table.toString() + r')';
  }

  static StructOfTableWithStringAndVector _ctor(List<Object> argv) => StructOfTableWithStringAndVector._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructOfTableWithStringAndVector> kStructOfTableWithStringAndVector_Type = $fidl.StructType<StructOfTableWithStringAndVector>(
  encodedSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<TableWithStringAndVector>(type: kTableWithStringAndVector_Type, offset: 0),
  ],
  ctor: StructOfTableWithStringAndVector._ctor,
);


class StructWithInt extends $fidl.Struct {
  const StructWithInt({
    @required this.x,
  });
  StructWithInt.clone(StructWithInt $orig, {
  int x,
  }) : this(
      x: x ?? $orig.x,
    );


  

  StructWithInt._(List<Object> argv)
    : x = argv[0];
  final int x;

  @override
  List<Object> get $fields {
    return <Object>[
      x,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructWithInt' r'(x: ' + x.toString() + r')';
  }

  static StructWithInt _ctor(List<Object> argv) => StructWithInt._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructWithInt> kStructWithInt_Type = $fidl.StructType<StructWithInt>(
  encodedSize: 4,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  ctor: StructWithInt._ctor,
);


class StructWithArrays extends $fidl.Struct {
  const StructWithArrays({
    @required this.arrEmpty,
    @required this.arrInt,
    @required this.arrString,
    @required this.arrStruct,
    @required this.arrArrInt,
  });
  StructWithArrays.clone(StructWithArrays $orig, {
  Int32List arrEmpty,
  Int32List arrInt,
  List<String> arrString,
  List<StructWithInt> arrStruct,
  List<Int32List> arrArrInt,
  }) : this(
      arrEmpty: arrEmpty ?? $orig.arrEmpty,
      arrInt: arrInt ?? $orig.arrInt,
      arrString: arrString ?? $orig.arrString,
      arrStruct: arrStruct ?? $orig.arrStruct,
      arrArrInt: arrArrInt ?? $orig.arrArrInt,
    );


  

  StructWithArrays._(List<Object> argv)
    : arrEmpty = argv[0],
      arrInt = argv[1],
      arrString = argv[2],
      arrStruct = argv[3],
      arrArrInt = argv[4];
  final Int32List arrEmpty;
  final Int32List arrInt;
  final List<String> arrString;
  final List<StructWithInt> arrStruct;
  final List<Int32List> arrArrInt;

  @override
  List<Object> get $fields {
    return <Object>[
      arrEmpty,
      arrInt,
      arrString,
      arrStruct,
      arrArrInt,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructWithArrays' r'(arrEmpty: ' + arrEmpty.toString() + r', arrInt: ' + arrInt.toString() + r', arrString: ' + arrString.toString() + r', arrStruct: ' + arrStruct.toString() + r', arrArrInt: ' + arrArrInt.toString() + r')';
  }

  static StructWithArrays _ctor(List<Object> argv) => StructWithArrays._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructWithArrays> kStructWithArrays_Type = $fidl.StructType<StructWithArrays>(
  encodedSize: 72,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Int32List>(type: $fidl.ArrayType<Int32List>(element: $fidl.Int32Type(), elementCount: 0), offset: 0),
    $fidl.MemberType<Int32List>(type: $fidl.ArrayType<Int32List>(element: $fidl.Int32Type(), elementCount: 2), offset: 0),
    $fidl.MemberType<List<String>>(type: $fidl.ArrayType<List<String>>(element: $fidl.StringType(maybeElementCount: null, nullable: false), elementCount: 2), offset: 8),
    $fidl.MemberType<List<StructWithInt>>(type: $fidl.ArrayType<List<StructWithInt>>(element: kStructWithInt_Type, elementCount: 2), offset: 40),
    $fidl.MemberType<List<Int32List>>(type: $fidl.ArrayType<List<Int32List>>(element: $fidl.ArrayType<Int32List>(element: $fidl.Int32Type(), elementCount: 3), elementCount: 2), offset: 48),
  ],
  ctor: StructWithArrays._ctor,
);


class StructWithVectors extends $fidl.Struct {
  const StructWithVectors({
    @required this.vecEmpty,
    @required this.vecInt,
    @required this.vecString,
    @required this.vecStruct,
    @required this.vecVecInt,
  });
  StructWithVectors.clone(StructWithVectors $orig, {
  Int32List vecEmpty,
  Int32List vecInt,
  List<String> vecString,
  List<StructWithInt> vecStruct,
  List<Int32List> vecVecInt,
  }) : this(
      vecEmpty: vecEmpty ?? $orig.vecEmpty,
      vecInt: vecInt ?? $orig.vecInt,
      vecString: vecString ?? $orig.vecString,
      vecStruct: vecStruct ?? $orig.vecStruct,
      vecVecInt: vecVecInt ?? $orig.vecVecInt,
    );


  

  StructWithVectors._(List<Object> argv)
    : vecEmpty = argv[0],
      vecInt = argv[1],
      vecString = argv[2],
      vecStruct = argv[3],
      vecVecInt = argv[4];
  final Int32List vecEmpty;
  final Int32List vecInt;
  final List<String> vecString;
  final List<StructWithInt> vecStruct;
  final List<Int32List> vecVecInt;

  @override
  List<Object> get $fields {
    return <Object>[
      vecEmpty,
      vecInt,
      vecString,
      vecStruct,
      vecVecInt,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'StructWithVectors' r'(vecEmpty: ' + vecEmpty.toString() + r', vecInt: ' + vecInt.toString() + r', vecString: ' + vecString.toString() + r', vecStruct: ' + vecStruct.toString() + r', vecVecInt: ' + vecVecInt.toString() + r')';
  }

  static StructWithVectors _ctor(List<Object> argv) => StructWithVectors._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructWithVectors> kStructWithVectors_Type = $fidl.StructType<StructWithVectors>(
  encodedSize: 80,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Int32List>(type: $fidl.VectorType<Int32List>(element: $fidl.Int32Type(), maybeElementCount: null, nullable: false), offset: 0),
    $fidl.MemberType<Int32List>(type: $fidl.VectorType<Int32List>(element: $fidl.Int32Type(), maybeElementCount: null, nullable: false), offset: 16),
    $fidl.MemberType<List<String>>(type: $fidl.VectorType<List<String>>(element: $fidl.StringType(maybeElementCount: null, nullable: false), maybeElementCount: null, nullable: false), offset: 32),
    $fidl.MemberType<List<StructWithInt>>(type: $fidl.VectorType<List<StructWithInt>>(element: kStructWithInt_Type, maybeElementCount: null, nullable: false), offset: 48),
    $fidl.MemberType<List<Int32List>>(type: $fidl.VectorType<List<Int32List>>(element: $fidl.VectorType<Int32List>(element: $fidl.Int32Type(), maybeElementCount: null, nullable: false), maybeElementCount: null, nullable: false), offset: 64),
  ],
  ctor: StructWithVectors._ctor,
);


class TableWithEmptyStruct extends $fidl.Table {
  const TableWithEmptyStruct({
    this.s,
  });

  TableWithEmptyStruct._(Map<int, dynamic> argv): s = argv[1];
  final EmptyStruct s;

  @override
  Map<int, dynamic> get $fields {
    return {
    1: s,
    };
  }

  static TableWithEmptyStruct _ctor(Map<int, dynamic> argv) => TableWithEmptyStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableWithEmptyStruct> kTableWithEmptyStruct_Type = $fidl.TableType<TableWithEmptyStruct>(
  encodedSize: 16,
  members: <int, $fidl.FidlType>{
    1: kEmptyStruct_Type,
  },
  ctor: TableWithEmptyStruct._ctor,
);


class XUnionInTable extends $fidl.Table {
  const XUnionInTable({
    this.before,
    this.xu,
    this.after,
  });

  XUnionInTable._(Map<int, dynamic> argv): before = argv[1],
      xu = argv[2],
      after = argv[3];
  final String before;
  final SampleXUnion xu;
  final String after;

  @override
  Map<int, dynamic> get $fields {
    return {
    1: before,
    2: xu,
    3: after,
    };
  }

  static XUnionInTable _ctor(Map<int, dynamic> argv) => XUnionInTable._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.TableType<XUnionInTable> kXUnionInTable_Type = $fidl.TableType<XUnionInTable>(
  encodedSize: 16,
  members: <int, $fidl.FidlType>{
    1: $fidl.StringType(maybeElementCount: null, nullable: false),
    2: kSampleXUnion_Type,
    3: $fidl.StringType(maybeElementCount: null, nullable: false),
  },
  ctor: XUnionInTable._ctor,
);


class SimpleTable extends $fidl.Table {
  const SimpleTable({
    this.x,
    this.y,
  });

  SimpleTable._(Map<int, dynamic> argv): x = argv[1],
      y = argv[5];
  final int x;
  final int y;

  @override
  Map<int, dynamic> get $fields {
    return {
    1: x,
    5: y,
    };
  }

  static SimpleTable _ctor(Map<int, dynamic> argv) => SimpleTable._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.TableType<SimpleTable> kSimpleTable_Type = $fidl.TableType<SimpleTable>(
  encodedSize: 16,
  members: <int, $fidl.FidlType>{
    1: $fidl.Int64Type(),
    5: $fidl.Int64Type(),
  },
  ctor: SimpleTable._ctor,
);


class TableWithStringAndVector extends $fidl.Table {
  const TableWithStringAndVector({
    this.foo,
    this.bar,
    this.baz,
  });

  TableWithStringAndVector._(Map<int, dynamic> argv): foo = argv[1],
      bar = argv[2],
      baz = argv[3];
  final String foo;
  final int bar;
  final Uint8List baz;

  @override
  Map<int, dynamic> get $fields {
    return {
    1: foo,
    2: bar,
    3: baz,
    };
  }

  static TableWithStringAndVector _ctor(Map<int, dynamic> argv) => TableWithStringAndVector._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableWithStringAndVector> kTableWithStringAndVector_Type = $fidl.TableType<TableWithStringAndVector>(
  encodedSize: 16,
  members: <int, $fidl.FidlType>{
    1: $fidl.StringType(maybeElementCount: null, nullable: false),
    2: $fidl.Int32Type(),
    3: $fidl.VectorType<Uint8List>(element: $fidl.Uint8Type(), maybeElementCount: null, nullable: false),
  },
  ctor: TableWithStringAndVector._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();


abstract class EthernetDevice extends $fidl.Service {
  static const String $serviceName = null;
  @override
  $fidl.ServiceData get $serviceData => EthernetDeviceData();
}

class EthernetDeviceData implements $fidl.ServiceData<EthernetDevice> {

  const EthernetDeviceData();

  @override
  String getName() {
    return EthernetDevice.$serviceName;
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return EthernetDeviceBinding();
  }
}
class EthernetDeviceProxy extends $fidl.AsyncProxy<EthernetDevice>
    implements EthernetDevice {
  EthernetDeviceProxy() : super($fidl.AsyncProxyController<EthernetDevice>($serviceName: null, $interfaceName: r'EthernetDevice')) {
    ctrl.onResponse = _handleResponse;

  }

  @override
  $fidl.ServiceData get $serviceData => EthernetDeviceData();

  void _handleEvent($fidl.Message $message) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError($fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }

  void _handleResponse($fidl.Message $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    final $fidl.Decoder $decoder = $fidl.Decoder($message);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError($fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }
}

class EthernetDeviceBinding extends $fidl.AsyncBinding<EthernetDevice> {
  EthernetDeviceBinding() : super(r"EthernetDevice");

  @override
  void handleMessage($fidl.Message $message, $fidl.MessageSink $respond) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message);
    switch ($message.ordinal) {
      default:
        throw $fidl.FidlError(r'Unexpected message name for EthernetDeviceBinding');
    }
  }
}


