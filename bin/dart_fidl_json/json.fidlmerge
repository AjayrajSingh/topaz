{{/*

FidlMerge Template for JSON generation.

*/}}

{{/* Produces the copyright messages for a file header. */}}
{{/* TODO: variable copyright year. */}}
{{- define "FileHeader" -}}
// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: This file is machine generated by fidlmerge.
// ignore_for_file: unnecessary_lambdas

{{- end }}

{{- define "FidlInclude" }}
import 'package:fidl{{- range .Name.Parts }}_{{ . }}{{ end }}/fidl.dart';
{{ end }}

{{/*
Generates the dart type from the specified Type as root.
*/}}
{{- define "DartType" -}}
{{- if eq .Kind "identifier" -}}
{{ template "TypeTemplate" .Identifier }}
{{- else if eq .Kind "string" -}}
String
{{- else if eq .Kind "primitive" -}}
{{- if eq .Subtype "bool" -}}
bool
{{- else if or (eq .Subtype "int32") (eq .Subtype "int8") (eq .Subtype "int32") (eq .Subtype "int64") (eq .Subtype "uint8") (eq .Subtype "uint16") (eq .Subtype "uint32") (eq .Subtype "uint64") -}}
int
{{- else if (eq .Subtype "float32") (eq .Subtype "float64") -}}
double
{{- end -}}
{{- end -}}
{{- end -}}

{{- define "EncodeFmt" -}}
{{- if eq .Kind "identifier" -}}
{{- printf "%s.toJson(%%s)" (execTmpl "CvtClassTemplate" .Identifier) -}}
{{- else -}}
%s
{{- end -}}
{{- end}}

{{- define "DecodeFmt" -}}
{{- if eq .Kind "identifier" -}}
{{- printf "%s.fromJson(%%s)" (execTmpl "CvtClassTemplate" .Identifier) -}}
{{- else -}}
%s
{{- end -}}
{{- end}}

{{/*
Generates a format string for encoding an object to json. First param is the
value expression and the second is the converter class.
*/}}
{{- define "ListEncodeFmtTemplate" -}}
{{- $encodeFmt := printf (execTmpl "EncodeFmt" .Type.ElementType) "val" -}}
{{- printf "%%s?.map((val)=>%s)?.toList()" $encodeFmt -}}
{{- end -}}

{{/*
Generates a format string for encoding an object to json. First param is the
value expression for the json object, the second is the converter class, and the
third is dart type.
*/}}
{{- define "ListDecodeFmtTemplate" -}}
{{- $decodeFmt := printf (execTmpl "DecodeFmt" .Type.ElementType) "val" -}}
{{- printf "%%s?.map((val)=>%1s)?.cast<%2s>()?.toList()" $decodeFmt (execTmpl "DartType" .Type.ElementType) -}}
{{- end -}}

{{/*
Generates Dart class name from fidl type. Root object is the type identifier.
*/}}
{{- define "TypeTemplate" }}{{ toUpperCamelCase .Parts.Name }}{{- end }}

{{/*
Generates Dart converter class name from fidl type. Root object is the type identifier.
*/}}
{{- define "CvtClassTemplate" }}{{ template "TypeTemplate" . }}Converter{{- end }}

{{/*
Generates JSON encoding expression format for the given member type.
*/}}
{{- define "EncodeMember" -}}
{{- if or (eq .Type.Kind "vector") (eq .Type.Kind "array") -}}
{{ template "ListEncodeFmtTemplate" . }}
{{- else -}}
{{ template "EncodeFmt" .Type }}
{{- end -}}
{{- end -}}

{{/*
Generates JSON decoding expression format for the given member type.
*/}}
{{- define "DecodeMember" -}}
{{- if or (eq .Type.Kind "vector") (eq .Type.Kind "array") -}}
{{ template "ListDecodeFmtTemplate" . }}
{{- else -}}
{{ template "DecodeFmt" .Type }}
{{- end -}}
{{- end -}}

{{- define "EnumConverterDecls" }}
  {{- range .Enums }}
{{- $type := execTmpl "TypeTemplate" .Name }}
class {{ $type }}Converter {
  static Object toJson(Object enumVal) {
    if (!(enumVal is {{ $type }})) {
      return null;
    }
    final Map<String, dynamic> map = {};
    switch(enumVal) {
    {{- range .Members }}
      {{- $val := toLowerCamelCase .Name }}
      case {{ $type }}.{{ $val }}:
        map['value'] = '{{.Name}}';
        break;
    {{- end}}
    }
    return map;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null || !json.containsKey('value')) {
      return null;
    }

    switch(json['value']) {
    {{- range .Members }}
      {{- $val := toLowerCamelCase .Name }}
      case '{{.Name}}':
        return {{ $type }}.{{ $val }};
    {{- end}}
    }

    return null;
  }
}
{{ end }}
{{- end }}

{{- define "StructConverterDecls" }}
  {{- range .Structs }}
{{- if eq .MaxHandles 0 }}
{{ $type := execTmpl "TypeTemplate" .Name }}
{{ $className := (execTmpl "CvtClassTemplate" .Name) }}
class {{ $className }} {
  static Object toJson(Object structVal) {
    if (structVal is {{ $type }}) {
      return {
      {{- range .Members }}
        {{- $member_name := toLowerCamelCase .Name }}
        {{- $value_expr := printf "structVal.%s" $member_name }}
          '{{ .Name }}': {{ printf (execTmpl "EncodeMember" .) $value_expr }},
      {{- end }}
      };
    }

    return null;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null) {
      return null;
    }

    return {{ $type }}(
{{- range .Members }}
  {{- $jsonVal := printf "json['%s']" .Name }}
      {{ toLowerCamelCase .Name}}: {{ printf (execTmpl "DecodeMember" .) $jsonVal }},
{{- end }}
    );
  }
}
{{- end }}
{{- end }}
{{- end }}

{{- define "UnionConverterDecls" -}}
  {{- range .Unions -}}
{{- if eq .MaxHandles 0 }}
{{- $type := execTmpl "TypeTemplate" .Name }}
{{- $typeKey := "type" }}
{{- $valueKey := "value" }}
{{- $className := (execTmpl "CvtClassTemplate" .Name) }}
class {{ $className }} {
  static Object toJson(Object unionVal) {
    if (unionVal is {{ $type }}) {
      switch(unionVal.tag) {
      {{- range .Members }}
        {{- $member_name := toLowerCamelCase .Name }}
         {{- $value_expr := print "unionVal." $member_name }}
        case {{ $type }}Tag.{{ $member_name }}:
          return {
            '{{ $typeKey }}': '{{ .Name }}',
            '{{ $valueKey }}': {{ printf (execTmpl "EncodeMember" .) $value_expr }},
          };
      {{- end }}
      }
    }

    return null;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null) {
      return null;
    }

    switch(json['{{ $typeKey }}']) {
    {{- range .Members }}
         {{- $member_ctor := printf "%s.with%s" $type (toUpperCamelCase .Name) -}}
         {{- $jsonVal := printf "json['%s']" $valueKey }}
      case '{{ .Name }}':
        return {{ $member_ctor}}({{ printf (execTmpl "DecodeMember" .) $jsonVal }});
    {{- end }}
    }

    return null;
  }
}
{{ end }}
{{- end }}
{{- end }}

{{- define "ImplementationFile" }}
  {{- template "FileHeader" . }}
  {{- template "FidlInclude" . }}
  {{- template "EnumConverterDecls" . }}
  {{- template "UnionConverterDecls" . }}
  {{- template "StructConverterDecls" . }}
{{- end }}

{{- define "Main" }}
  {{- $file_path := .Output ".dart" }}
  {{- .Generate $file_path "ImplementationFile" . }}
{{- end }}
