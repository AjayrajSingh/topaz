{{/*

FidlMerge Template for JSON generation.

*/}}

{{/* Produces the copyright messages for a file header. */}}
{{/* TODO: variable copyright year. */}}
{{- define "FileHeader" -}}
// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: This file is machine generated by fidlmerge.
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unused_import

{{- end }}

{{- define "FidlInclude" }}
import 'dart:typed_data';
import 'package:fidl{{- range .Name.Parts }}_{{ . }}{{ end }}/fidl_async.dart';
{{ end }}

{{/*
Generates the dart type from the specified Type as root.
*/}}
{{- define "DartType" -}}
{{- if eq .Kind "identifier" -}}
{{ template "TypeTemplate" .Identifier }}
{{- else if eq .Kind "string" -}}
String
{{- else if eq .Kind "primitive" -}}
{{- $type := .PrimitiveSubtype }}
{{- if eq $type "bool" -}}
bool
{{- else if or (eq $type "int32") (eq $type "int8") (eq $type "uint8") (eq $type "int32") (eq $type "int64") (eq $type "uint8") (eq $type "uint16") (eq $type "uint32") (eq $type "uint64") -}}
int
{{- else if (eq $type "float32") (eq $type "float64") -}}
double
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Returns the list type for numerical based primitives.
*/}}
{{- define "DartNumericalPrimitiveListType" -}}
{{- if eq . "int8" -}}
Int8List
{{- else if eq . "int16" -}}
Int16List
{{- else if eq . "int32" -}}
Int32List
{{- else if eq . "int64" -}}
Int64List
{{- else if eq . "uint8" -}}
Uint8List
{{- else if eq . "uint16" -}}
Uint16List
{{- else if eq . "uint32" -}}
Uint32List
{{- else if eq . "uint64" -}}
Uint64List
{{- else if eq . "float32" -}}
Float32List
{{- else if eq . "float64" -}}
Float64List
{{- end -}}
{{- end -}}


{{/*
Generates the dart list type from the specified Type as root.
*/}}
{{- define "DartListConvertFmt" -}}
{{- if eq .Kind "primitive" -}}
{{- $type := .PrimitiveSubtype }}
{{- if eq $type "bool" -}}
%s
{{- else -}}
{{- printf (execTmpl "DartNumericalPrimitiveListType" $type) }}.fromList(%s)
{{- end -}}
{{- else -}}
%s
{{- end -}}
{{- end -}}


{{- define "EncodeFmt" -}}
{{- if eq .Kind "identifier" -}}
{{- printf "%s.toJson(%%s)" (execTmpl "CvtClassTemplate" .Identifier) -}}
{{- else -}}
%s
{{- end -}}
{{- end}}

{{- define "DecodeFmt" -}}
{{- if eq .Kind "identifier" -}}
{{- printf "%s.fromJson(%%s)" (execTmpl "CvtClassTemplate" .Identifier) -}}
{{- else -}}
%s
{{- end -}}
{{- end}}

{{/*
Generates a format string for encoding an object to json. First param is the
value expression and the second is the converter class.
*/}}
{{- define "ListEncodeFmtTemplate" -}}
{{- $encodeFmt := printf (execTmpl "EncodeFmt" .Type.ElementType) "val" -}}
{{- printf "%%s?.map((val)=>%s)?.toList()" $encodeFmt -}}
{{- end -}}

{{/*
Generates a format string for encoding an object to json. First param is the
value expression for the json object, the second is the converter class, and the
third is dart type.
*/}}
{{- define "ListDecodeFmtTemplate" -}}
{{- $decodeFmt := printf (execTmpl "DecodeFmt" .Type.ElementType) "val" -}}
{{- $convert := printf "%%s?.map((val)=>%1s)?.cast<%2s>()?.toList()" $decodeFmt (execTmpl "DartType" .Type.ElementType) -}}
{{- printf (execTmpl "DartListConvertFmt" .Type.ElementType) $convert -}}
{{- end -}}

{{/*
Generates Dart class name from fidl type. Root object is the type identifier.
*/}}
{{- define "TypeTemplate" }}{{ toUpperCamelCase .Parts.Name }}{{- end }}

{{/*
Generates Dart converter class name from fidl type. Root object is the type identifier.
*/}}
{{- define "CvtClassTemplate" }}{{ template "TypeTemplate" . }}Converter{{- end }}

{{/*
Generates JSON encoding expression format for the given member type.
*/}}
{{- define "EncodeMember" -}}
{{- if or (eq .Type.Kind "vector") (eq .Type.Kind "array") -}}
{{ template "ListEncodeFmtTemplate" . }}
{{- else -}}
{{ template "EncodeFmt" .Type }}
{{- end -}}
{{- end -}}

{{/*
Generates JSON decoding expression format for the given member type.
*/}}
{{- define "DecodeMember" -}}
{{- if or (eq .Type.Kind "vector") (eq .Type.Kind "array") -}}
{{ template "ListDecodeFmtTemplate" . }}
{{- else -}}
{{ template "DecodeFmt" .Type }}
{{- end -}}
{{- end -}}

{{- define "EnumConverterDecls" }}
  {{- range .Enums }}
{{- $type := execTmpl "TypeTemplate" .Name }}
class {{ $type }}Converter {
  static Object toJson(Object enumVal) {
    if (!(enumVal is {{ $type }})) {
      return null;
    }
    final Map<String, dynamic> map = {};
    switch(enumVal) {
    {{- range .Members }}
      {{- $val := toLowerCamelCase .Name }}
      case {{ $type }}.{{ $val }}:
        map['value'] = '{{.Name}}';
        break;
    {{- end}}
    }
    return map;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null || !json.containsKey('value')) {
      return null;
    }

    switch(json['value']) {
    {{- range .Members }}
      {{- $val := toLowerCamelCase .Name }}
      case '{{.Name}}':
        return {{ $type }}.{{ $val }};
    {{- end}}
    }

    return null;
  }
}
{{ end }}
{{- end }}

{{- define "TableConverterDecls" }}
  {{- range .Tables }}
{{- if eq .MaxHandles 0 }}
{{ $type := execTmpl "TypeTemplate" .Name }}
{{ $className := (execTmpl "CvtClassTemplate" .Name) }}
class {{ $className}} {
  static Object toJson(Object tableVal) {
    if (tableVal is {{ $type }}) {
      return {
      {{- range .Members }}
        {{- if not .Reserved }}
        {{- $member_name := toLowerCamelCase .Name }}
        {{- $value_expr := printf "tableVal.%s" $member_name }}
        '{{ .Name }}': {{ printf (execTmpl "EncodeMember" .) $value_expr }},
        {{- end }}
      {{- end }}
      };
    }
    return null;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null) {
      return null;
    }

    return {{ $type }}(
{{- range .Members }}
  {{- if eq .Reserved false }}
  {{- $jsonVal := printf "json['%s']" .Name }}
      {{ toLowerCamelCase .Name}}: {{ $jsonVal }} != null ? {{ printf (execTmpl "DecodeMember" .) $jsonVal }} : null,
  {{- end }}
{{- end }}
    );
  }
}

{{- end }}
  {{- end }}
{{- end }}

{{- define "StructConverterDecls" }}
  {{- range .Structs }}
{{- if eq .MaxHandles 0 }}
{{ $type := execTmpl "TypeTemplate" .Name }}
{{ $className := (execTmpl "CvtClassTemplate" .Name) }}
class {{ $className }} {
  static Object toJson(Object structVal) {
    if (structVal is {{ $type }}) {
      return {
      {{- range .Members }}
        {{- $member_name := toLowerCamelCase .Name }}
        {{- $value_expr := printf "structVal.%s" $member_name }}
          '{{ .Name }}': {{ printf (execTmpl "EncodeMember" .) $value_expr }},
      {{- end }}
      };
    }

    return null;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null) {
      return null;
    }

    return {{ $type }}(
{{- range .Members }}
  {{- $jsonVal := printf "json['%s']" .Name }}
      {{ toLowerCamelCase .Name}}: {{ $jsonVal }} != null ? {{ printf (execTmpl "DecodeMember" .) $jsonVal }} : null,
{{- end }}
    );
  }
}
{{- end }}
{{- end }}
{{- end }}

{{- define "UnionConverterDecls" -}}
  {{- range . -}}
{{- if eq .MaxHandles 0 }}
{{- $type := execTmpl "TypeTemplate" .Name }}
{{- $typeKey := "type" }}
{{- $valueKey := "value" }}
{{- $className := (execTmpl "CvtClassTemplate" .Name) }}
class {{ $className }} {
  static Object toJson(Object unionVal) {
    if (unionVal is {{ $type }}) {
      switch(unionVal.$tag) {
      {{- range .Members }}
        {{- $member_name := toLowerCamelCase .Name }}
         {{- $value_expr := print "unionVal." $member_name }}
        case {{ $type }}Tag.{{ $member_name }}:
          return {
            '{{ $typeKey }}': '{{ .Name }}',
            '{{ $valueKey }}': {{ printf (execTmpl "EncodeMember" .) $value_expr }},
          };
      {{- end }}
      }
    }

    return null;
  }

  static {{ $type }} fromJson(Map<String, dynamic> json) {
    if (json == null) {
      return null;
    }

    switch(json['{{ $typeKey }}']) {
    {{- range .Members }}
         {{- $member_ctor := printf "%s.with%s" $type (toUpperCamelCase .Name) -}}
         {{- $jsonVal := printf "json['%s']" $valueKey }}
      case '{{ .Name }}':
        return {{ $member_ctor}}({{ printf (execTmpl "DecodeMember" .) $jsonVal }});
    {{- end }}
    }

    return null;
  }
}
{{ end }}
{{- end }}
{{- end }}

{{- define "ImplementationFile" }}
  {{- template "FileHeader" . }}
  {{- template "FidlInclude" . }}
  {{- template "EnumConverterDecls" . }}
  {{- template "UnionConverterDecls" .Unions }}
  {{- template "UnionConverterDecls" .XUnions }}
  {{- template "StructConverterDecls" . }}
  {{- template "TableConverterDecls" . }}
{{- end }}

{{- define "Main" }}
  {{- $file_path := .Output ".dart" }}
  {{- .Generate $file_path "ImplementationFile" . }}
{{- end }}
