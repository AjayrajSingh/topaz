// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// WARNING: This file is machine generated by fidlgen.

library fidl_test_name_test;

import 'dart:async' show Future, Stream;
import 'dart:core' hide Error;
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart';

import './fidl_async.dart';

// ignore_for_file: always_specify_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: library_prefixes
// ignore_for_file: unused_shown_name

class OvernetInternalProtocol$TestBase extends OvernetInternalProtocol {
  @override
  Future<void> methodA(int a, int b) {
    return Future.error(UnimplementedError());
  }
  @override
  Stream<OvernetInternalProtocol$EventA$Response> get eventA {
    return Stream.fromFuture(Future.error(UnimplementedError()));
  }
  @override
  Future<int> methodB(int a, int b) {
    return Future.error(UnimplementedError());
  }

}


class SocketControlProtocol$TestBase extends SocketControlProtocol {
  @override
  Future<void> methodA(int a, int b) {
    return Future.error(UnimplementedError());
  }
  @override
  Stream<SocketControlProtocol$EventA$Response> get eventA {
    return Stream.fromFuture(Future.error(UnimplementedError()));
  }
  @override
  Future<int> methodB(int a, int b) {
    return Future.error(UnimplementedError());
  }

}


class ChannelProtocol$TestBase extends ChannelProtocol {
  @override
  Future<void> methodA(int a, int b) {
    return Future.error(UnimplementedError());
  }
  @override
  Stream<ChannelProtocol$EventA$Response> get eventA {
    return Stream.fromFuture(Future.error(UnimplementedError()));
  }
  @override
  Future<int> methodB(int a, int b) {
    return Future.error(UnimplementedError());
  }

}


class KitchenSink$TestBase extends KitchenSink {
  @override
  Future<void> methodA(int a, int b) {
    return Future.error(UnimplementedError());
  }
  @override
  Stream<KitchenSink$EventA$Response> get eventA {
    return Stream.fromFuture(Future.error(UnimplementedError()));
  }
  @override
  Future<int> methodB(int a, int b) {
    return Future.error(UnimplementedError());
  }

}


